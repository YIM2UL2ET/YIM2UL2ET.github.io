---
published: false
title: 동적계획법(Dynamic Programming)
layout: post
date: 2024-11-05 00:21:00 +09:00
categories: [PS, 알고리즘]
tags: [PS, 알고리즘, 동적계획법, DP, 테크닉]
math: true
---

## **동적계획법** ##

#### **개요** ####
문제를 부분 문제로 나눈 후, 해당 부분 문제의 최적해를 결합하여 문제의 최적해를 구할 수 있을 때
중복되는 부분 문제의 답을 저장해 두었다가 재활용하는 알고리즘 설계 방식

#### **사전지식** ####

#### **조건** ####
총 두 조건이 만족한다면 동적계획법을 활용할 수 있다.

- 중복되는 부분 문제(Overlapping Subproblems): 
  부분 문제들의 최적해가 두 번 이상 중복으로 활용되는 경우에만 활용이 가능하다. 
  그렇지 않을 경우 부분 문제를 여러번 계산할 필요가 없으므로 동적계획법을 활용할 필요가 없다.

- 최적 부분 구조(Optimal Substructure):
  문제의 최적해를 찾고자 할 때 부분 문제들에 대한 최적해를 찾고, 이를 결합하여 문제의 최적해가 나와야 활용이 가능하다.
  만약 부분 문제를 활용하여도 문제의 최적해를 구하지 못한다면 동적계획법으로는 제대로 된 값을 구하는 것이 불가능할 것이다.

## **구현 방식** ##

#### **사용되는 기법 및 테크닉** ####
- 메모이제이션(Memoization) 기법:
  함수의 결괏값을 저장해 두었다가 재활용하는 최적화 기법이다.
  해당 기법을 사용하기 위해서는 참조적 투명성(referential transparency)이 적용되어야 한다.

  참조적 투명성이란 함수의 반환 값이 입력 값만으로 결정되는 것을 뜻한다. 
  이는 다시말해 입력이 고정되어 있다면 출력도 고정되어 있어야 함을 뜻한다.

- 표(Tabulation) 기법:
  
- 슬라이딩 윈도우(Sliding Window) 테크닉:
  

#### **Top-Down** ####
구하고자 하는 문제를 호출 후 이를 풀이하기 위한 작은 문제를 재귀적으로 호출하여 최종적인 최적해를 찾는 구현 방식
메모이제이션(Memoization) 기법을 사용하고, 재귀 호출(Recursive Call)을 활용하여 구현한다.

풀이하는 대략적인 플로우는 다음과 같다.
1. 부분 문제를 설계하며 최적해를 반환하는 완전 탐색(bruteforce) 알고리즘 설계
2. 최적 부분 구조가 설립할 경우 함수에 최대한 부분 문제의 최적해만을 활용하는 부분 문제로 변환
3. 적절한 변환을 통하여 메모이제이션

#### **Bottom-Up** ####
가장 작은 문제부터 해결하며 최종적인 문제의 최적해를 찾는 구현 방식
표(Tabulation) 기법을 사용하고, 반복자(Iterater)를 활용하여 구현한다.

해당 풀이 방식은 슬라이딩 윈도우 기법으로 메모리 사용량을 줄일 수 있다.

#### **비교** ####

|  | Top-Down | Bottom-Up |
| -- | -- | -- |
| 접근 방식 | 큰 문제 - > 작은 문제| 작은 문제 -> 큰 문제 |
| 기법 | 메모이제이션(Memoization) | 표(Tabulation) |
| 구현 | 재귀 호출(Recursive Call) | 반복(Iteration) |
| 장점 | 직관적 | 메모리 사용량 및 성능이 비교적 우월 |
| 단점 | 스택 오버플로우가 날 가능성이 존재 | 최적해를 구할 때 사용되지 않는 부분 문제까지 계산 |

## **웰노운 테크닉들** ##

#### **행렬 거듭제곱을 이용한 DP (exponentiation_by_squaring)** ####
분할정복을 활용하여 행렬의 거듭제곱을 $O(n^3log{m})$의 시간복잡도로 풀이할 수 있다는 것을 선형 점화식 DP에 활용하는 테크닉이다.

분량이 너무 길어지므로 [이 글](https://driip.me/00556a4c-0782-4c5b-a86a-8e27e5f4ac1b) 참조 (추후 정리 예정)

#### **비트마스킹을 활용한 DP (bit_dp)** ####

#### **트리DP (tree_dp)** ####
추후 추가예정

## **웰노운 문제들** ##

#### **배낭문제(knapsack problem)** ####

#### **LIS(Longest Increasing Subsequence)** ####

## **기타** ##

#### **참조** ####
- [프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 - 동적계획법](https://product.kyobobook.co.kr/detail/S000001032946)
- [[Algorithm] Dynamic Programming (동적 계획법) - dEpayse](https://medium.com/depayse/algorithm-dynamic-programming-%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95-2484e5cb82bd)

#### **마르코프 연쇄 모델** ####

현실 세계의 현상들을 모델링 하기 위하여 사용되는 모델이다. 성질은 아래와 같다.

- 유한개의 상태가 존재.
- 매 시간마다 상태가 변경됨.
- 현재 상태 a에서 다른 상태 b로 옮겨갈 확률은 a에 좌우. 이때 a 이전의 상태나 시간은 영향을 주지 않음.
