---
published: false
title: 동적계획법(Dynamic Programming)
layout: post
date: 2024-11-05 00:21:00 +09:00
categories: [PS, 알고리즘]
tags: [PS, 알고리즘, 동적계획법, DP, 테크닉]
math: true
---

## **동적계획법** ##

#### **개요** ####
문제를 부분 문제로 나눈 후, 해당 부분 문제의 최적해를 결합하여 문제의 최적해를 구할 수 있을 때
중복되는 부분 문제의 답을 저장해 두었다가 재활용하는 알고리즘 설계 방식

#### **조건** ####
총 두 조건이 만족한다면 동적계획법을 활용할 수 있다.

- 중복되는 부분 문제(Overlapping Subproblems): 
  부분 문제들의 최적해가 두 번 이상 중복으로 활용되는 경우에만 활용이 가능하다. 
  그렇지 않을 경우 부분 문제를 여러번 계산할 필요가 없으므로 동적계획법을 활용할 필요가 없다.

- 최적 부분 구조(Optimal Substructure):
  문제의 최적해를 찾고자 할 때 부분 문제들에 대한 최적해를 찾고, 이를 결합하여 문제의 최적해가 나와야 활용이 가능하다.
  만약 부분 문제를 활용하여도 문제의 최적해를 구하지 못한다면 제대로 된 값을 구하는 것이 불가능할 것이다.

#### **메모이제이션(memoization)** ####
한번 계산된 값을 저장해 두었다가 재활용 하는 방식의 최적화 기법
이때 계산한 값을 저장해 두는 메모리 공간을 캐시(cache)라고 한다.

메모이제이션은 참조적 투명성이 적용될 경우에만 적용 가능하다.

*참조적 투명성: "함수의 반환 값이 입력 값만으로 결정되는가"에 대한 성질

## **구현** ##

#### **Top-Down** ####

대략적인 플로우는 다음과 같다.
1. 부분 문제를 설계하며 최적해를 반환하는 완전 탐색(bruteforce) 알고리즘 설계
2. 최적 부분 구조가 설립할 경우 함수에 최대한 부분 문제의 최적해만을 활용하는 부분 문제로 변환
3. 적절한 변환을 통하여 메모이제이션

#### **Bottom-Up** ####

#### **비교** ####

## **웰노운 테크닉들**##

#### **배낭문제(knapsack problem)** ####

#### **LIS(Longest Increasing Subsequence)** ####

## **참조**##
- [프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 - 동적계획법](https://product.kyobobook.co.kr/detail/S000001032946)
- [](https://medium.com/depayse/algorithm-dynamic-programming-%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95-2484e5cb82bd)
