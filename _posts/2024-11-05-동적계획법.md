---
published: false
title: 동적계획법(Dynamic Programming)
layout: post
date: 2024-11-05 00:21:00 +09:00
categories: [PS, 알고리즘]
tags: [PS, 알고리즘, 동적계획법, DP, 테크닉]
math: true
---

## **동적계획법** ##

#### **개요** ####
문제를 부분 문제로 나눈 후, 해당 부분 문제의 최적해를 결합하여 문제의 최적해를 구할 수 있을 때
중복되는 부분 문제의 답을 저장해 두었다가 재활용하는 알고리즘 설계 방식

#### **조건** ####
총 두 조건이 만족한다면 동적계획법을 활용할 수 있다.

- 중복되는 부분 문제(Overlapping Subproblems): 
  부분 문제들의 최적해가 두 번 이상 중복으로 활용되는 경우에만 활용이 가능하다. 
  그렇지 않을 경우 부분 문제를 여러번 계산할 필요가 없으므로 동적계획법을 활용할 필요가 없다.

- 최적 부분 구조(Optimal Substructure):
  문제의 최적해를 찾고자 할 때 부분 문제들에 대한 최적해를 찾고, 이를 결합하여 문제의 최적해가 나와야 활용이 가능하다.
  만약 부분 문제를 활용하여도 문제의 최적해를 구하지 못한다면 제대로 된 값을 구하는 것이 불가능할 것이다.

## **구현 방식** ##

#### **사용되는 기법** ####
- 메모이제이션(Memoization) 기법:

- 표(Tabulation) 기법:

#### **Top-Down** ####
구하고자 하는 문제를 호출 후 이를 풀이하기 위한 작은 문제를 재귀적으로 호출하여 최종적인 최적해를 찾는 구현 방식
메모이제이션(Memoization) 기법을 사용하고, 재귀 호출(Recursive Call)을 활용하여 구현한다.

풀이하는 대략적인 플로우는 다음과 같다.
1. 부분 문제를 설계하며 최적해를 반환하는 완전 탐색(bruteforce) 알고리즘 설계
2. 최적 부분 구조가 설립할 경우 함수에 최대한 부분 문제의 최적해만을 활용하는 부분 문제로 변환
3. 적절한 변환을 통하여 메모이제이션

#### **Bottom-Up** ####
가장 작은 문제부터 해결하며 최종적인 문제의 최적해를 찾는 구현 방식
표(Tabulation) 기법을 사용하고, 반복자(Iterater)를 활용하여 구현한다.

#### **비교** ####

|  | Top-Down | Bottom-Up |
| -- | -- | -- |
| 접근 방식 | 큰 문제 - > 작은 문제| 작은 문제 -> 큰 문제 |
| 기법 | 메모이제이션(Memoization) | 표(Tabulation) |
| 구현 | 재귀 호출(Recursive Call) | 반복(Iteration) |
| 단점 | 스택 오버플로우가 날 가능성이 존재 | 최적해를 구할 때 사용되지 않는 부분 문제까지 계산 |

## **웰노운 테크닉들** ##

#### **배낭문제(knapsack problem)** ####

#### **LIS(Longest Increasing Subsequence)** ####

## **기타** ##

#### **참조** ####
- [프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 - 동적계획법](https://product.kyobobook.co.kr/detail/S000001032946)
- [[Algorithm] Dynamic Programming (동적 계획법) - dEpayse](https://medium.com/depayse/algorithm-dynamic-programming-%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95-2484e5cb82bd)

#### **마르코프 연쇄 모델** ####

현실 세계의 현상들을 모델링 하기 위하여 사용되는 모델이다. 성질은 아래와 같다.

- 유한개의 상태가 존재.
- 매 시간마다 상태가 변경됨.
- 현재 상태 a에서 다른 상태 b로 옮겨갈 확률은 a에 좌우. 이때 a 이전의 상태나 시간은 영향을 주지 않음.
