---
published: true
title: MITM 알고리즘
layout: post
date: 2024-08-31 00:21:00 +09:00
categories: [PS, 알고리즘]
tags: [PS, 알고리즘, MITM, 중간에서 만나기]
---

## **개요**
Meet int the middle (중간에서 만나기), 줄여서 MITM 알고리즘이란
부르트포스 알고리즘을 사용하여 문제를 해결할 때 시간복잡도를 줄이기 위해서 사용되는 테크닉으로, 
쉽게 설명하면 문제를 반으로 나누어 각각 해결한 후 중간에서 만나 최종적인 문제를 해결하는 알고리즘이다.

## **BOJ 2295 (세 수의 합)**
https://www.acmicpc.net/problem/2295

보통 쉽게 생각하는 방식은 `x, y, z번째 수`를 합한 집합을 만든 후 입력된 수들 중 최댓값을 찾는 방식을 생각할 것이다.
이는 아무리 짧게 잡아도 최소 $$O(n^3)$$의 시간 복잡도가 나오게 될 것이다.

여기서 문제를 약간만 변형해보자<br>
"`x번째 수 + y번째 수 = k번째 수 - z번째 수` 를 만족하는 `k번째 수` 중 최댓값을 구하시오"

`x번째 수 + y번째 수`인 집합을 생성하고, `k번째 수 - z번째 수`인 집합을 생성하는 방식을 생각하게 되지 않는가?

두 집합을 생성하는데에 $$O(n^2)$$, 이분탐색 또는 해시를 사용하여 탐색을 수행하면 
$$O(n\cdot logn)$$, 또는 $$O(n^2)$$의 시간 복잡도가 걸리므로
총합 $$O(n^2)$$의 시간복잡도를 가지게 된다.

```C++
#include <iostream>
#include <algorithm>
#include <vector>
#include <unordered_set>

using namespace std;

int main() {
    int n, result;
    cin >> n;
    
    vector <int> nums(n);
    for (auto &el : nums) {
        cin >> el;
    }

    sort(nums.begin(), nums.end());
    
    unordered_set <int> setA;
    for (int x = 0; x < n; x++) {
        for (int y = x; y < n; y++) {
            setA.insert(nums[x] + nums[y]);
        }    
    }
    
    result = 0;
    for (int z = 0; z < n; z++) {
        for (int k = z; k < n; k++) {
            if (setA.find(nums[k] - nums[z]) != setA.end()) {
                result = max(nums[k], result);
            }
        }    
    }
    
    cout << result;
    
    return 0;
}
```

## **참조**
[MITM, sqrt Decomposition - 안즈의 소소한 취미생활](https://anz1217.tistory.com/127)<br>
